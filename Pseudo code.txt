Recursion
1. Permutation

input: return list(result), input array(a), step(step), process element(e), duplicate array(d)(if necessary)
procedure:
	//for integer array
	if(step==a.size())
		Add e to result;
		return;
	for i from 0 to a.size()
		//Check duplicate
		if i>0, a[i]=a[i-1], d[i-1]=1 
			continue
		d[i]=1;
		add a[i] to e
		call dfs(result, a, step+1,e,d)
		delete the last element in e
		d[i]=0;

	//for string
	if(step==a.length())
		Add s to result
		return;
	for i from step to s.length
		swap(a[step],a[i])
		call dfs(result,a,step+1)
		swap(a[step],a[i])

2. Subset
Input: result, a(sorted), e, step
Procedure:
	for i from step to a.size
		Add a[i] to e
		Add e to result
		Call dfs(rsult,a,e,i+1)
		Delete the last element in e
		while(i<a.size && a[i]=a[i-1]) i++;

Bianry Tree
1. Recover Binary Search Tree (O(n) time, O(1) space)
Input: root node
Procedure:
	Initialize prev=n1=n2=p=null, curr=root
	while curr != null
	    if curr does not have left subtree
		if prev exists and prev.val>curr.val
		    if n1=null
			n1=prev
		    n2=curr
		update prev, and move curr to its right
	   else
		set p to curr's left child
		find inorder predecessor of p
		if right child of inorder predecessor of p does not exist
		    set p's right child as curr
		    move curr to its left child
		else
		    set p's right child to null
		    if prev exists and prev.val>curr.val
		    if n1=null
			n1=prev
		    n2=curr
		update prev, and move curr to its right
	Swap value of n1 and n2

Word Break
1. Check if an input string a break in dictionary
	bool[n+1] w, initialized false
	for i from 1 to n
	    if w[i]=false, and s.substring(0,i) is in dictionary
		w[i]=true
 	    if w[i]=true
		if reaches the last character, return true
		for j from i+1 to n
		    if w[j]=false, and s.substring(i,j) is in the dictionary
			w[j]=true
		    if reaches the last character and w[j]=true
			return true
	return false

2. Return all possible word breakdowns
	bool[n+1] w, initialized true
	backtracking input: list(result), w, s, str(stringbuffer), step(0), length(s.length)
	if reaches the end of s
	    Add str.substring(0,str.length-1) to result //Delete trailing spaces
	    return
	for i from step to length-1
	    if w[i+1]=true, and s.substring(step, i+1) is in dictionary
		Add s.substring(step, i+1) and a trailing space to str
		Record instantaneous length of result
		call func with i+1
		if result.size=recorded length
		    w[i+1]=false;
		Trim size of str by s.substring(step, i+1)+1 

Paint House II
Input int[][] costs
Procedure:
	Initialize m=costs.size, n=costs[0].size
	Create dp[n]
	for i from 0 to m-1
	    Save previous minimum costs (prev1) and second minimum costs(prev2)
	    Declare current minimum (curr1) and second minimum cost (curr2) as INT_MAX
	    for j from 0 to n-1
		if dp[j]=prev1
		    Set dp[j]=costs[i][j]+prev2
		else 
		    Set dp[j]=costs[i][j]+prev1
		if dp[j]<=curr1
		    curr2=curr1
		    curr1=dp[j]
		else
		    curr2=min(curr2,dp[j])
	return curr1

Palindrome Permutation II
Procedure:
	1. key method
	Input: String s
	Create result(vector/list), str(string), odd(int), hmap(hash map<char,int>)
	for each character c in s
	    hmap[c]++;	//Count times of appearance of distinct characters
	for each key in hmap
	    if(hmap[key] is odd)
		odd++;
		if(odd==2) return result;	//No palindrome permutation
		Add key to str;	//Save character that appear odd times
	Call dfs
	return result
	
	2. dfs
	Input: result(vector/list), str(string), hmap(hash map<char,int>, int odd
	Create: flag(bool)=true
	for each key in hmap
	    if hmap[key]>1
		set flag to false;	//Still have unoperated character
		hmap[key]-2;	//operate each key in pairs
		add key to str;
		call dfs(result,str,hmap,odd)
		hmap[key]+2;	//recover all keys in hash map for next permutation
	if flag is true	//All characters have been operated
	    Create s(string)
	    s=str.substring from odd to str.length
	    reverse s
	    add both s and str to result

Populating next right pointer II
Input: TreeLinkNode root
Procedure:
	Create q(node,level)(queue<pair<TreeLinkNode,int>>), level=0
	Add (root,0) to q
	Initialize node as root	
	while(true)
	    Set level to q.front.level+1
	    if node has	left child
		add node's left child to q
	    if node has right child
		add node's right child to q
	    if reaches the last node in tree, break
	    pop front of q to p(Pair)
	    if p.level equals to q.front.level
		set p.node's next pointer to q.front.node
	    else
		set p.node's next pointer to null
	    set node's next pointer to q.front.node
	set node's next pointer to null

Count univalue subtree
Input root(TreeNode)
Procedure:
	Create count=0(int)
	dfs(root)
	    if root is null, return true
	    recursively get l(bool), r(bool)
	    if l and r and root.left is null or root.val=root.left.val and root.right is null or root.val=root.right.val
		count++
		return true
	    return false