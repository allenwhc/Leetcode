1. Permutation

input: return list(result), input array(a), step(step), process element(e), duplicate array(d)(if necessary)
procedure:
	//for integer array
	if(step==a.size())
		Add e to result;
		return;
	for i from 0 to a.size()
		//Check duplicate
		if i>0, a[i]=a[i-1], d[i-1]=1 
			continue
		d[i]=1;
		add a[i] to e
		call dfs(result, a, step+1,e,d)
		delete the last element in e
		d[i]=0;

	//for string
	if(step==a.length())
		Add s to result
		return;
	for i from step to s.length
		swap(a[step],a[i])
		call dfs(result,a,step+1)
		swap(a[step],a[i])


2. Subset
Input: result, a(sorted), e, step
Procedure:
	for i from step to a.size
		Add a[i] to e
		Add e to result
		Call dfs(rsult,a,e,i+1)
		Delete the last element in e
		while(i<a.size && a[i]=a[i-1]) i++;


3. Recover Binary Search Tree (O(n) time, O(1) space)
Input: root node
Procedure:
	Initialize prev=n1=n2=p=null, curr=root
	while curr != null
	    if curr does not have left subtree
		if prev exists and prev.val>curr.val
		    if n1=null
			n1=prev
		    n2=curr
		update prev, and move curr to its right
	   else
		set p to curr's left child
		find inorder predecessor of p
		if right child of inorder predecessor of p does not exist
		    set p's right child as curr
		    move curr to its left child
		else
		    set p's right child to null
		    if prev exists and prev.val>curr.val
		    if n1=null
			n1=prev
		    n2=curr
		update prev, and move curr to its right
	Swap value of n1 and n2

4. Word Break
1) Check if an input string a break in dictionary
	bool[n+1] w, initialized false
	for i from 1 to n
	    if w[i]=false, and s.substring(0,i) is in dictionary
		w[i]=true
 	    if w[i]=true
		if reaches the last character, return true
		for j from i+1 to n
		    if w[j]=false, and s.substring(i,j) is in the dictionary
			w[j]=true
		    if reaches the last character and w[j]=true
			return true
	return false

2) Return all possible word breakdowns
	bool[n+1] w, initialized true
	backtracking input: list(result), w, s, str(stringbuffer), step(0), length(s.length)
	if reaches the end of s
	    Add str.substring(0,str.length-1) to result //Delete trailing spaces
	    return
	for i from step to length-1
	    if w[i+1]=true, and s.substring(step, i+1) is in dictionary
		Add s.substring(step, i+1) and a trailing space to str
		Record instantaneous length of result
		call func with i+1
		if result.size=recorded length
		    w[i+1]=false;
		Trim size of str by s.substring(step, i+1)+1 

5. Paint House II
Input int[][] costs
Procedure:
	Initialize m=costs.size, n=costs[0].size
	Create dp[n]
	for i from 0 to m-1
	    Save previous minimum costs (prev1) and second minimum costs(prev2)
	    Declare current minimum (curr1) and second minimum cost (curr2) as INT_MAX
	    for j from 0 to n-1
		if dp[j]=prev1
		    Set dp[j]=costs[i][j]+prev2
		else 
		    Set dp[j]=costs[i][j]+prev1
		if dp[j]<=curr1
		    curr2=curr1
		    curr1=dp[j]
		else
		    curr2=min(curr2,dp[j])
	return curr1

6. Palindrome Permutation II
Procedure:
	1. key method
	Input: String s
	Create result(vector/list), str(string), odd(int), hmap(hash map<char,int>)
	for each character c in s
	    hmap[c]++;	//Count times of appearance of distinct characters
	for each key in hmap
	    if(hmap[key] is odd)
		odd++;
		if(odd==2) return result;	//No palindrome permutation
		Add key to str;	//Save character that appear odd times
	Call dfs
	return result
	
	2. dfs
	Input: result(vector/list), str(string), hmap(hash map<char,int>, int odd
	Create: flag(bool)=true
	for each key in hmap
	    if hmap[key]>1
		set flag to false;	//Still have unoperated character
		hmap[key]-2;	//operate each key in pairs
		add key to str;
		call dfs(result,str,hmap,odd)
		hmap[key]+2;	//recover all keys in hash map for next permutation
	if flag is true	//All characters have been operated
	    Create s(string)
	    s=str.substring from odd to str.length
	    reverse s
	    add both s and str to result

7. Populating next right pointer II
Input: TreeLinkNode root
Procedure:
	Create q(node,level)(queue<pair<TreeLinkNode,int>>), level=0
	Add (root,0) to q
	Initialize node as root	
	while(true)
	    Set level to q.front.level+1
	    if node has	left child
		add node's left child to q
	    if node has right child
		add node's right child to q
	    if reaches the last node in tree, break
	    pop front of q to p(Pair)
	    if p.level equals to q.front.level
		set p.node's next pointer to q.front.node
	    else
		set p.node's next pointer to null
	    set node's next pointer to q.front.node
	set node's next pointer to null

8. Count univalue subtree
Input root(TreeNode)
Procedure:
	Create count=0(int)
	dfs(root)
	    if root is null, return true
	    recursively get l(bool), r(bool)
	    if l and r and root.left is null or root.val=root.left.val and root.right is null or root.val=root.right.val
		count++
		return true
	    return false

9. Factors Combination
Input n(int)
Procedure:
	dfs(allFactors(2d vector/list), factors(1d vector/list), n(int), start(int)
	if(n<=1)
	    if more than 1 element is in factors
		add factors to allFactors
	    return;
	for i from start to n
	    if n can be divided by i
		add i to factors
		call dfs(allFactors, factors, n/i, i)
		delete last element in factors

10. Verify Preorder Sequence in BST
Input: preorder(int[])
Procedure:
	Create stack(Stack<int>), last(int, initialized as -1)
	for i from 0 to preorder.length-1
	    if cuurent element is less than last
		return false
	    while current element is greater than top of stack
		pop top of stack to last
	    push current element to stack
	return true

11. Find k nodes whose value are closest to target
Procedure:
    1) closestKValues
        Input: root(TreeNode), target(double), k(int)
        Create two stacks: predecessor, successor; result(vector/list)
	call inorderTraverse(root,target,false(forward),predecessor)
	call inorderTraverse(root,target,true(reverse),successor)
	while k from k to 1
	    if predecessor is empty
		pop top of successor to result
	    else if successor is empty
		pop top of predecessor to result
	    else 
		if abs of target-predecessor.top is less than abs of target-successor.top
		    pop top of predecessor to result
		else
		    pop top of succesor to result
	return result

    2) Inorder Traverse
        Input: node(TreeNode), target(double), reverse(bool), stack(Stack<int>)
        Procedure:
	    traverse left(forward)/right(reverse) subtree
	    if forward and current node value is greater than target or reverse and current node value is less than or equal to target
		return		//Found the crossover point
	    traverse right(forward)/left(reverse) subtree  

12. Largest Rectangle Area in Histogram
Procedure: largestRectangleArea
Input: height(int[])
	Create stack(Stack<int>), i=0(int), maxArea=int_min(int)
	while i from 0 to height.size-1
	    if stack is empty of height[i] is not less than top of stack
		push i to stack
		increment i
		continue
	    pop top of stack to j
	    if stack is empty
		set width to i
	    else
		set width to i-stack.top-1
	    update maxArea comparing to height[j]*width
	while stack is not empty
	    pop top of stack to j
	    if stack is empty
		set width to i
	    else
		set width to i-stack.top-1
	    update maxArea comparing to height[j]*width
	return maxArea
	
13. Missing Range
Method/Function: missingRange
Input: nums(int[]), lower(int), upper(int)
	Create range(vector/list), prev=0(int)
	if nums is empty
		add (lower,upper) to range
	if nums[0] is greater than lower
		add (lower, nums[0]-1) to range
		prev=nums[0]
	else 
		prev=lower
	for each num in nums
		if num-prev>1 
			add (prev+1, num-1) to range
		prev=num
	if upper is greater than prev
		add (prev+1, upper) to range
	return range
	
14. Strobogrammatic Number
	1)Procedure: Determine if a number is strobogrammtic
	  Input: num(string)
	  	Create str=00 11 88 696(string), left=0(int), right=num.len-1(int)
	  	for left from 0 to right, and right from num.len-1 to left
	  		if str does not contain num[left]+""+num[right] 
	  			return false
	  	return true
	  	
	2)Procedure: Generate all strobogrammatic numbers given number of digits
	  Input: n(int)
	  	Create result(vector/list<string>), str(string/stringbuffer), left(0, int), right(n-1, int)
	  	Call dfs(result,str,left,right)
	  	if left exceeds right
	  		add str to result
	  		return
	  	else if left equals to right
	  		add '0' to str[left]
	  		call dfs(result,str,left+1,right-1)
	  		add '1' to str[left]
	  		call dfs(result,str,left+1,right-1)
	  		add '8' to str[left]
	  		call dfs(result,str,left+1,right-1)
	  	else
	  		if left is not 0
	  			add '0' to both str[left] and str[right]
	  			call dfs(result,str,left+1,right-1)
	  		add '1' to both str[left] and str[right]
	  			call dfs(result,str,left+1,right-1)
	  		add '8' to both str[left] and str[right]
	  			call dfs(result,str,left+1,right-1)
	  		add '6' to str[left] and '9' to str[right]
	  			call dfs(result,str,left+1,right-1)
	  		add '9' to str[left] and '6' to str[right]
	  			call dfs(result,str,left+1,right-1)
	
		3)Procedure: Count number of strobogrammatic numbers in a specific range
		  i) strobogrammaticInRange
		  	 Input: low(string), high(string)
		  	 	Create hmap(hashmap<char,char>)
		  	 	Initialize hmap('0'->'0', '1'->'1', '8'->'8', '6'->'9', '9'->'6')
		  	 	for n from low.len to high.len
		  	 		Create count(int[1])
		  	 		Call getCount(hmap,new char[n],count,low, high,0,n-1)
		  	 		result+=count[0]
		  	 	return reuslt
		  	 	
		  ii) getCount
		  	  Input: hmap(hashmap), str(char[n]), count(int[1]), low(string), high(string), start(int), end(int)
		  	  	if start exceeds end
		  	  		str.len=1 or str[0]!='0' and compare(low, str.tostring) and compare(str.tostring, high)
		  	  			count[0]++
		  	  		return
		  	  	for each key in hmap
		  	  		str[start]=key
		  	  		str[end]=key->value
		  	  		if start=end and key=key->val or start<end
		  	  			Call getCount(hmap,new char[n],count,low, high,start+1,end-1)
		  
		  iii)compare
		  	  Input: a(string), b(string)
		  	  	if a and b have different sizes
		  	  		return size of a < size of b
		  	  	Create i=0(int)
		  	  	while i is less than size of a and a[i]=b[i]
		  	  		increment i
		  	  	if i equals to size of a
		  	  		return true
		  	  	else
		  	  		return a[i]<=b[i]
		  	  		
15. Binary Tree Upside-down
	Procedure: upsideDownBinaryTree
	Input: root(TreeNode)
		if root is null
			return null
		if root is leaf node
			return root
		Recursively create node(TreeNode) by iterating left child
		Change root's left left child to right child
		Change root's left right child to root
		Set root't left and right child to null
		return node
		
16. Merge Sort Singly-linked List
	1)Procedure: sortList
	  Input: head(ListNode)
	  	if list is empty or has only one element 
	  		return head
	  	Call split(head)
	  	Set midNode(ListNode)=split(head)
	  	Set head of second half to midNode.next
	  	Terminate the first half
	  	return mergeSort(sortList(head), sortList(head of second half))
	  	
	2)Procedure: mergeSort
	  Input: head1(ListNode), head2(ListNode)
	  	Create a preHead(ListNode), curr(preHead, ListNode)
	  	while two half lists are both not empty
	  		if head1.val<=head2.val
	  			curr.next=head1.val
	  			head1 moves to next node
	  		else
	  			curr.next=head2.val
	  			head2 moves to next node
	  		move curr to next
	  	if head1 is null
	  		set curr.next=head2
	  	else
	  		set curr.next=head1
	  	return preHead.next
	 
	3)Procedure: split
	  Input: head(ListNode)
	   	if head is null 
	   		return null
	   	Set slow(ListNode), fast(ListNode) to head
	   	Use slow and fast to find middle node of current list
	   	return middle node

17. Insertion Sort Singly-linked List
	Procedure: insertionSort
	Input: head(ListNode)
		Create a temp node(ListNode(int_min))
		while head is valid
		    Create curr(ListNode) as head
		    Create prev(ListNode) as temp
		    Move head to next node
		    while prev's next node exists and its value is less than curr's value
			move prev to next node
		    Change curr's next node to prev's next node
		    Change prev's next node to curr
		return temp's next node
		
18. H-index II
	Procedure: hIndex
	Input: citations(int[], sorted in ascending order)
		Create l(0, int), r(n-1, int)
		while l is less than r
			Set m to be middle point of l and r
			if citations[m] is less than n-m
				Set l to be m+1
			else
				Set r to be m
		if citations[r] equals to 0
			return 0
		else 
			return n-r
			
19. Flatten 2D vector (JAVA)
	Create two private members: x(Iterator<List<Integer>>), y(Iterator<Integer>)
	1)Method: Vector2D (Constructor)
	  Input: vec2d(2D List)
	  	Set x=vec2d.iterator;
	
	2)Method: next (int)
	  Input: null
	  	call hasNext
	  	return y.next()
	
	3)Method: hasNext (boolean)
	  Input: null
	  	while y is null or y doesn't have next and x has next
	  		y=x.next.iterator
	  	return y is not null? and y has next
	  	
20. Flatten Binary Tree
	Procedure: convert
	Input: node(root, TreeNode), prev(null, TreeNode[])
		if node is null 
			return
		Save node's right child to right
		if prev[0] is not null
			Set prev[0]'s right child to node
		Set prev[0] to node
		Call convert(node.left,prev)
		Set node's left child to null
		Call convert(right,prev)
		
21. Edit Distance
	Procedure: minDistance
	Input: word1(string), word2(string)
		Create m(word1.len, int), n(word2.len, int)
		Create dp(int[m][n])
		Initialize first row and column of dp
		for i from 0 to m-1
			for j from 0 to n-1
				Create c1(word1[i], char), c2(word2[j], char)
				if c1 equals to c2
					set dp[i+1][j+1] as dp[i][j]	//No need to operate
				else
					Create replacement(dp[i][j]+1, int)	
					Create deletion(dp[i+1][j]+1, int)
					Create insertion(dp[i][j+1]+1, int)
					Find minimum value among replacement, deletion, insertion
					set dp[i+1][j+1] as the minimum value
		return dp[m][n]